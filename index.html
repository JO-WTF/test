<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <!-- ç¦ç”¨ç¼©æ”¾ + å…¨é¢å±é€‚é… -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>æ‰‹æœºæ‰«ç  - çŠ¶æ€æ›´æ–°å«å¤‡æ³¨/ç…§ç‰‡ï¼ˆVue 3 + @zxing/browserï¼‰</title>
  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- ä»…ä½¿ç”¨ @zxing/browserï¼ˆUMD å…¨å±€ä¸º ZXingBrowserï¼‰ -->
  <script src="https://unpkg.com/@zxing/browser@0.1.5"></script>

  <!-- å…œåº•ï¼šç¦æ­¢æåˆ/åŒå‡»ç¼©æ”¾ï¼ˆæ”¾åœ¨æœ€å‰é¢å°½æ—©ç”Ÿæ•ˆï¼‰ -->
  <script>
    // ç¦ç”¨æ‰‹åŠ¿ç¼©æ”¾ï¼ˆiOS Safariï¼‰
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // æŠ‘åˆ¶åŒå‡»æ”¾å¤§ï¼ˆä¸å½±å“è¾“å…¥/æŒ‰é’®ç­‰äº¤äº’ï¼‰
    let __lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
      const now = Date.now();
      if (now - __lastTouchEnd <= 300) {
        const t = e.target;
        if (!t.closest('input, textarea, select, a, button, label, [role="button"]')) {
          e.preventDefault();
        }
      }
      __lastTouchEnd = now;
    }, { passive: false });

    // å¯é€‰ï¼šé˜»æ­¢ Ctrl/Meta + æ»šè½®ç¼©æ”¾ï¼ˆæ¡Œé¢ç«¯åœºæ™¯ï¼‰
    window.addEventListener('wheel', function(e){
      if (e.ctrlKey || e.metaKey) e.preventDefault();
    }, { passive: false });
  </script>

  <style>
    :root { --fg:#eaf2ff; --bg:#0b1020; --accent:#69a8ff; --muted:#8aa2c8; --ok:#66e6a4; --err:#ff9aa6; }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%}

    /* å…³é”®ï¼šé¿å… iOS è‡ªåŠ¨æ”¾å¤§æ–‡å­—/è¡¨å•ï¼Œç¦ç”¨åŒå‡»ç¼©æ”¾ */
    html,body{
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }

    body{margin:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:24px 16px 40px;gap:16px}
    h1{font-size:18px;margin:0 0 4px;text-align:center;font-weight:600}

    /* æ‰«ææ¡†åŒºåŸŸï¼š16:9 */
    .scan-area{position:relative;width:min(84vw,520px);aspect-ratio:16/9;border-radius:16px;overflow:hidden;background:#000}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    .corners{position:absolute;inset:0;pointer-events:none}
    .c{position:absolute;width:18%;height:40%;border:3px solid var(--accent)}
    .tl{left:10px;top:10px;border-right:0;border-bottom:0;border-radius:12px 0 0 0}
    .tr{right:10px;top:10px;border-left:0;border-bottom:0;border-radius:0 12px 0 0}
    .bl{left:10px;bottom:10px;border-right:0;border-top:0;border-radius:0 0 0 12px}
    .br{right:10px;bottom:10px;border-left:0;border-top:0;border-radius:0 0 12px 0}

    .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    button{appearance:none;border:0;border-radius:999px;padding:12px 16px;font-weight:600;background:#12182b;color:var(--fg);font-size:16px}
    .primary{background:var(--accent);color:#07122b}
    .ghost{background:#12182b;color:var(--fg)}
    button[disabled]{opacity:.6}
    .tag{font-size:12px;padding:8px 10px;border-radius:999px;background:#0f1730;border:1px solid #1f2a4d}

    .card{width:min(92vw,720px);background:#101831;border:1px solid #1f2a4d;border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:12px}
    .card h2{font-size:16px;margin:0}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

    /* çŠ¶æ€æ›´æ–°åŒºå— */
    .status-box{padding:14px;border:2px solid var(--accent);border-radius:12px;background:#0b1327;display:flex;flex-direction:column;gap:12px}
    .status-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .status-row label{font-weight:700}
    select.status{min-width:180px;font-size:16px;padding:10px 12px;border-radius:10px;border:1px solid #2a3a66;background:#0e1631;color:var(--fg)}

    .flex-2{display:flex;gap:12px;flex-wrap:wrap}
    .flex-2 > .col{flex:1 1 300px}
    textarea{width:100%;min-height:96px;resize:vertical;border-radius:12px;border:1px solid #2a3a66;background:#0e1631;color:var(--fg);padding:10px 12px;font-size:16px}

    .uploader{border:1px dashed #2a3a66;border-radius:12px;padding:12px;display:flex;gap:12px;align-items:flex-start}
    .uploader input[type=file]{display:block;font-size:16px}
    .thumb{width:96px;height:96px;border-radius:10px;background:#081028;border:1px solid #20305a;object-fit:cover}

    /* å…³é”®ï¼šè¾“å…¥æ§ä»¶å­—å· >=16pxï¼Œé¿å…èšç„¦è‡ªåŠ¨ç¼©æ”¾ */
    input, select, textarea { font-size:16px; }

    .ok{color:var(--ok)}
    .err{color:var(--err)}

    /* â€”â€” è¿›åº¦æ¡ â€”â€” */
    .progress{position:relative;height:10px;background:#0f1730;border:1px solid #1f2a4d;border-radius:999px;overflow:hidden}
    .progress-bar{height:100%;background:var(--accent);transition:width .2s ease}
    .progress.indeterminate .progress-bar{width:30%;animation:indet 1.2s infinite}
    @keyframes indet{0%{transform:translateX(-100%)}100%{transform:translateX(300%)}}
    .progress-text{margin-top:6px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
<div id="app" class="wrap">
  <div>
    <h1>ğŸ“· æ‰«ç </h1>
  </div>

  <section class="scan-area">
    <video ref="video" playsinline muted autoplay></video>
    <div class="corners">
      <div class="c tl"></div>
      <div class="c tr"></div>
      <div class="c bl"></div>
      <div class="c br"></div>
    </div>
  </section>

  <div class="tag" v-if="state.torchSupported">é—ªå…‰ç¯ï¼š<b>{{ state.torchOn ? 'å¼€' : 'å…³' }}</b></div>

  <div class="row" v-if="!state.last">
    <button class="primary" @click="start" :disabled="state.running">å¼€å§‹æ‰«æ</button>
    <button class="ghost" @click="stop" :disabled="!state.running">åœæ­¢</button>
    <button class="ghost" @click="toggleTorch" :disabled="!state.running || !state.torchSupported">åˆ‡æ¢é—ªå…‰ç¯</button>
  </div>

  <div class="card" v-if="state.last">
    <div class="row">
      <button class="primary" @click="resume">é‡æ–°æ‰«æ</button>
    </div>
    <h2>è¯†åˆ«ç»“æœ</h2>
    <div class="mono">{{ state.last.text }}</div>

    <template v-if="state.isValid">
      <div class="status-box">
        <div class="status-row">
          <label for="duStatus">æ›´æ–° DU çŠ¶æ€ï¼š</label>
          <select id="duStatus" class="status" v-model="state.duStatus">
            <option value="" disabled>è¯·é€‰æ‹©</option>
            <option value="è¿è¾“ä¸­">è¿è¾“ä¸­</option>
            <option value="å·²åˆ°è¾¾">å·²åˆ°è¾¾</option>
          </select>
        </div>

        <div class="flex-2">
          <div class="col">
            <label style="display:block;margin-bottom:6px">å¤‡æ³¨ä¿¡æ¯</label>
            <textarea v-model="state.remark" placeholder="å¯å¡«å†™é¢å¤–è¯´æ˜â€¦"></textarea>
          </div>
          <div class="col">
            <label style="display:block;margin-bottom:6px">ä¸Šä¼ ç…§ç‰‡</label>
            <div class="uploader">
              <img v-if="state.photoPreview" :src="state.photoPreview" alt="é¢„è§ˆ" class="thumb" />
              <div style="display:flex;flex-direction:column;gap:8px">
                <input type="file" accept="image/*" capture="environment" @change="onPickPhoto" />
                <small class="muted">æ”¯æŒæ‹ç…§æˆ–ä»ç›¸å†Œé€‰æ‹©</small>
                <button v-if="state.photoFile" class="ghost" @click="clearPhoto">ç§»é™¤ç…§ç‰‡</button>
              </div>
            </div>
          </div>
        </div>

        <button class="primary" style="align-self:flex-start" @click="submitUpdate" :disabled="!state.duStatus || state.submitting">
          {{ state.submitting ? 'æäº¤ä¸­â€¦' : 'æäº¤' }}
        </button>

        <!-- æäº¤è¿›åº¦æ¡ï¼šæœ‰ç…§ç‰‡ => ç™¾åˆ†æ¯”ï¼›æ— ç…§ç‰‡ => ä¸ç¡®å®šåŠ¨ç”» -->
        <div v-if="state.submitting">
          <div class="progress" :class="{'indeterminate': !state.photoFile}">
            <div class="progress-bar" :style="{ width: (state.photoFile ? state.uploadPct : 100) + '%' }"></div>
          </div>
          <div class="progress-text">
            {{ state.photoFile ? ('ä¸Šä¼ ä¸­ï¼š' + state.uploadPct + '%') : 'æäº¤ä¸­â€¦' }}
          </div>
        </div>

        <div v-if="state.submitMsg" :class="[state.submitOk ? 'ok' : 'err']">{{ state.submitMsg }}</div>
      </div>
    </template>

    <template v-else>
      <div class="err">æ— æ•ˆçš„DU ID</div>
    </template>
  </div>
</div>

<script>
const { createApp, ref, reactive, onMounted, onBeforeUnmount } = Vue;

createApp({
  setup(){
    const video = ref(null);

    const API_URL = (window.API_URL || 'https://jakartabackend.onrender.com/api/du/update');

    // ä»…å¯ç”¨å¸¸è§æ ¼å¼ï¼Œå‡å°‘è¯¯æ£€æé€Ÿ
    function createReader(){
      try{
        const hints = new Map();
        const F = ZXingBrowser.BarcodeFormat;
        const H = ZXingBrowser.DecodeHintType;
        hints.set(H.POSSIBLE_FORMATS, [F.QR_CODE, F.CODE_128, F.CODE_39, F.EAN_13, F.EAN_8]);
        return new ZXingBrowser.BrowserMultiFormatReader(hints, 250);
      }catch{ return new ZXingBrowser.BrowserMultiFormatReader(); }
    }
    const reader = createReader();

    const state = reactive({
      running:false,
      last:null,
      locked:false,
      torchSupported:false,
      torchOn:false,
      isValid:false,
      duStatus:"",
      remark:"",
      photoFile:null,
      photoPreview:"",
      submitting:false,
      submitOk:false,
      submitMsg:"",
      uploadPct: 0, // <â€”â€” æ–°å¢ï¼šä¸Šä¼ ç™¾åˆ†æ¯”
    });

    let controls = null;
    let inactivityTimer = null;
    const DIGIT_DU_RE = /^\d{10,20}$/;

    function clearInactivity(){ if(inactivityTimer){ clearTimeout(inactivityTimer); inactivityTimer=null; } }
    function startInactivityCountdown(){
      clearInactivity();
      inactivityTimer = setTimeout(()=>{ stop(); }, 2*60*1000);
    }

    async function detectTorchSupport(){
      try{
        const stream = video.value?.srcObject;
        const track = stream?.getVideoTracks?.()[0];
        const caps = track?.getCapabilities?.();
        state.torchSupported = !!(caps && 'torch' in caps);
      }catch{ state.torchSupported = false; }
    }

    async function applyTorch(on){
      try{
        const stream = video.value?.srcObject;
        const track = stream?.getVideoTracks?.()[0];
        if(!track) return;
        await track.applyConstraints({ advanced:[{ torch: !!on }] });
        state.torchOn = !!on;
      }catch{ state.torchOn = false; }
    }

    async function enhanceTrack(){
      try{
        const stream = video.value?.srcObject;
        const track = stream?.getVideoTracks?.()[0];
        if(!track) return;
        // è¿ç»­å¯¹ç„¦ï¼ˆéƒ¨åˆ†æœºå‹æ”¯æŒï¼‰
        try{ const ic = new ImageCapture(track); await ic.setOptions?.({ focusMode: 'continuous' }); }catch{}
        // é€‚åº¦å˜ç„¦åˆ°çº¦ 1.3xï¼ˆå¦‚æ”¯æŒï¼‰
        try{ const caps = track.getCapabilities?.(); if(caps?.zoom){ const z=caps.zoom; const t=Math.min(z.max, Math.max(z.min||1,(z.min||1)*1.3)); await track.applyConstraints({ advanced: [{ zoom: t }] }); } }catch{}
      }catch{}
    }

    async function buildBackCameraConstraints(){
      const tries = [
        { video: { facingMode: { exact: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
      ];
      for(const c of tries){
        try{ const s = await navigator.mediaDevices.getUserMedia(c); s.getTracks().forEach(t=>t.stop()); return c; }catch{}
      }
      try{ const devices = await navigator.mediaDevices.enumerateDevices(); const cams = devices.filter(d=>d.kind==='videoinput'); const back = cams.find(d=>!/front|user/i.test(d.label)) || cams[0]; if(back){ return { video: { deviceId: { exact: back.deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio:false }; } }catch{}
      return { video: { width: { ideal: 1280 }, height: { ideal: 720 } }, audio:false };
    }

    const start = async ()=>{
      if (state.running) return;
      try{
        state.running = true;
        state.locked = false;
        clearInactivity();
        try{ controls?.stop(); }catch{}

        let constraints = await buildBackCameraConstraints();
        try{
          controls = await reader.decodeFromConstraints(
            constraints,
            video.value,
            async (result, err, _controls) => {
              if (result && !state.locked) {
                state.locked = true;
                const text = result.getText();
                const format = result.getBarcodeFormat();
                state.isValid = DIGIT_DU_RE.test(text);
                state.duStatus = "";
                state.remark = "";
                clearPhoto();
                state.submitMsg = "";
                state.submitOk = false;
                state.last = { text, format };
                try{ _controls.stop(); }catch{}
                try{ reader.reset(); }catch{}
                await applyTorch(false);
                await detectTorchSupport();
                state.running = false;
                clearInactivity();
                try{ navigator.vibrate?.(30); }catch{}
              }
            }
          );
        }catch(e){
          if(e && (e.name==='OverconstrainedError' || e.name==='NotFoundError')){
            constraints = { video: true, audio:false };
            controls = await reader.decodeFromConstraints(constraints, video.value, ()=>{});
          }else{ throw e; }
        }

        await enhanceTrack();
        await detectTorchSupport();
        startInactivityCountdown();
      }catch(e){
        console.error(e);
        alert('æ— æ³•å¯åŠ¨æ‘„åƒå¤´æˆ–å¼€å§‹è§£ç ï¼š' + (e?.name || '') + (e?.message ? (' - ' + e.message) : ''));
        state.running = false;
      }
    }

    const hardStopStream = ()=>{
      const s = video.value?.srcObject;
      if (s && s.getTracks) s.getTracks().forEach(t=>{ try{ t.stop(); }catch{} });
      if (video.value) video.value.srcObject = null;
      state.torchOn = false;
      state.torchSupported = false;
    }

    const stop = async ()=>{
      try{ controls?.stop(); }catch{}
      try{ reader.reset(); }catch{}
      try{ await applyTorch(false); }catch{}
      hardStopStream();
      state.running=false; state.locked=false;
      clearInactivity();
    }

    const resume = async ()=>{ state.last=null; state.locked=false; state.isValid=false; state.duStatus=""; state.remark=""; clearPhoto(); state.submitMsg=""; state.submitOk=false; await start() }

    const onPickPhoto = (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      state.photoFile = file;
      try{ state.photoPreview = URL.createObjectURL(file); }catch{ state.photoPreview = ''; }
    }

    const clearPhoto = ()=>{
      try{ state.photoPreview && URL.revokeObjectURL(state.photoPreview); }catch{}
      state.photoPreview = '';
      state.photoFile = null;
    }

    // â€”â€” ä½¿ç”¨ XHR è·å–ä¸Šä¼ è¿›åº¦ â€”â€” //
    const submitUpdate = async ()=>{
      if(!state.isValid){ state.submitOk=false; state.submitMsg='æ— æ•ˆçš„DU ID'; return }
      if(!state.duStatus){ state.submitOk=false; state.submitMsg='è¯·é€‰æ‹©è¦æ›´æ–°çš„çŠ¶æ€'; return }

      state.submitting = true;
      state.submitMsg = '';
      state.submitOk = false;
      state.uploadPct = 0;

      try{
        const isPlaceholder = !API_URL || /<ä½ çš„-render-åŸŸå>/.test(API_URL)
        if(isPlaceholder){
          throw new Error('æœªé…ç½®åç«¯ API_URLï¼Œè¯·åœ¨é¡µé¢é¡¶éƒ¨é€šè¿‡ window.API_URL æˆ–ç›´æ¥æ”¹ä»£ç è®¾ç½®çœŸå®åœ°å€')
        }

        const fd = new FormData();
        fd.append('duId', state.last.text);
        fd.append('status', state.duStatus);
        fd.append('remark', state.remark || '');
        if(state.photoFile) fd.append('photo', state.photoFile);

        const xhr = new XMLHttpRequest();
        xhr.open('POST', API_URL, true);

        // ä¸Šä¼ è¿›åº¦
        xhr.upload.onprogress = (e)=>{
          if(e && e.lengthComputable){
            state.uploadPct = Math.min(100, Math.round(e.loaded / e.total * 100));
          }
        };

        xhr.onerror = ()=>{ state.submitOk = false; state.submitMsg = 'æäº¤å¤±è´¥ï¼šç½‘ç»œé”™è¯¯'; state.submitting = false; };
        xhr.onabort = ()=>{ state.submitOk = false; state.submitMsg = 'æäº¤å·²å–æ¶ˆ'; state.submitting = false; };

        xhr.onreadystatechange = ()=>{
          if(xhr.readyState !== 4) return;
          const status = xhr.status;
          const text = xhr.responseText || '';
          let data = null; try{ data = text ? JSON.parse(text) : null }catch{}
          if(status >= 200 && status < 300){
            const ok = (data && (data.ok===true || data.success===true)) || true;
            state.submitOk = !!ok;
            state.submitMsg = ok ? (data?.message || 'æäº¤æˆåŠŸ') : (data?.message || 'æäº¤å¤±è´¥');
            state.uploadPct = 100;
            if(ok){ setTimeout(()=>{ resume() }, 600); }
          }else{
            const msg = (data && (data.detail || data.message)) || ('HTTP ' + status);
            state.submitOk = false;
            state.submitMsg = 'æäº¤å¤±è´¥ï¼š' + msg;
          }
          state.submitting = false;
        };

        xhr.send(fd);
      }catch(err){
        console.error(err);
        state.submitOk = false;
        state.submitMsg = 'æäº¤å¤±è´¥ï¼š' + (err?.message || err);
        state.submitting = false;
      }
    };

    onMounted(async ()=>{
      video.value?.setAttribute('playsinline','true');
      video.value?.setAttribute('muted','muted');
      document.addEventListener('visibilitychange', ()=>{ if (document.hidden) stop() });
      window.addEventListener('pagehide', stop);
      await start(); // æ‰“å¼€é¡µé¢è‡ªåŠ¨å¼€å¯æ‘„åƒå¤´
    })

    onBeforeUnmount(()=>{ stop() })

    return { state, video, start, stop, resume, toggleTorch: async ()=>{ if(state.torchSupported) await applyTorch(!state.torchOn) }, submitUpdate, onPickPhoto, clearPhoto }
  }
}).mount('#app');
</script>
</body>
</html>
